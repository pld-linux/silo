diff -Nur silo-1.4.13/Rules.make silo/Rules.make
--- silo-1.4.13/Rules.make	2006-06-21 07:51:03.000000000 +0000
+++ silo/Rules.make	2007-10-08 17:39:27.959921000 +0000
@@ -1,5 +1,6 @@
 VERSION=1.4.13
 IMGVERSION=0.99
+SHELL=/bin/bash
 RM=rm -f
 # We want to force 32-bit builds
 CC=gcc -m32
@@ -13,10 +14,17 @@
 SMALL_RELOC=0x280000
 LARGE_RELOC=0x380000
 
-CFLAGS=-Os -Wall -I. -I../include -fomit-frame-pointer \
+cc-option-yn = $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null -xc /dev/null \
+		> /dev/null 2>&1; then echo "y"; else echo "n"; fi;)
+
+CFLAGS = -Os -Wall -I. -I../include -fomit-frame-pointer \
 	-fno-strict-aliasing -DSMALL_RELOC=$(SMALL_RELOC) \
 	-DLARGE_RELOC=$(LARGE_RELOC)
 
+ifeq ($(call cc-option-yn, -fno-stack-protector),y)
+CFLAGS += -fno-stack-protector
+endif
+
 OPSYS=$(shell uname)
 OSREV=$(shell uname -r)
 ifeq ($(OPSYS),SunOS)
diff -Nur silo-1.4.13/common/inflate.c silo/common/inflate.c
--- silo-1.4.13/common/inflate.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/common/inflate.c	2007-10-08 17:39:27.959921000 +0000
@@ -958,13 +958,17 @@
     if ((flags & RESERVED) != 0) {
 	error ("Input has invalid flags");
     }
-    (ulg) get_byte ();		/* Get timestamp */
-    (ulg) get_byte ();
-    (ulg) get_byte ();
-    (ulg) get_byte ();
 
-    (void) get_byte ();		/* Ignore extra flags for the moment */
-    (void) get_byte ();		/* Ignore OS type for the moment */
+    /* Ignore timestamp */
+    (void) get_byte ();
+    (void) get_byte ();
+    (void) get_byte ();
+    (void) get_byte ();
+
+    /* Ignore extra flags for the moment */
+    (void) get_byte ();
+    /* Ignore OS type for the moment */
+    (void) get_byte ();
 
     if ((flags & EXTRA_FIELD) != 0) {
 	unsigned len = (unsigned) get_byte ();
diff -Nur silo-1.4.13/first/Makefile silo/first/Makefile
--- silo-1.4.13/first/Makefile	2006-06-01 17:24:53.000000000 +0000
+++ silo/first/Makefile	2007-10-08 17:39:27.963921250 +0000
@@ -42,7 +42,7 @@
 
 first.b: first
 	$(ELFTOAOUT) -o first.b first
-	echo -n 'SILO'$(IMGVERSION) | $(DD) of=first.b bs=8 conv=notrunc seek=3 count=1
+	printf 'SILO'$(IMGVERSION) | $(DD) of=first.b bs=8 conv=notrunc seek=3 count=1
 	$(DD) if=/dev/zero of=first.b bs=4 count=1 seek=127
 
 ultra.o: ultra.S
@@ -55,8 +55,8 @@
 
 ultra.b: ultra
 	$(ELFTOAOUT) -o ultra.b ultra
-	echo -n 'SILO'$(IMGVERSION) | $(DD) of=ultra.b bs=8 conv=notrunc seek=3 count=1
-	echo -n -e '\340' | $(DD) of=ultra.b bs=1 count=1 seek=7 conv=notrunc
+	printf 'SILO'$(IMGVERSION) | $(DD) of=ultra.b bs=8 conv=notrunc seek=3 count=1
+	printf '\340' | $(DD) of=ultra.b bs=1 count=1 seek=7 conv=notrunc
 	$(DD) if=/dev/zero of=ultra.b bs=4 count=1 seek=127
 
 generic.o: generic.S
@@ -69,8 +69,8 @@
 
 generic.b: generic
 	$(ELFTOAOUT) -o generic.b generic
-	echo -n 'SILO'$(IMGVERSION) | $(DD) of=generic.b bs=8 conv=notrunc seek=3 count=1
-	echo -n -e '\340' | $(DD) of=generic.b bs=1 count=1 seek=7 conv=notrunc
+	printf 'SILO'$(IMGVERSION) | $(DD) of=generic.b bs=8 conv=notrunc seek=3 count=1
+	printf '\340' | $(DD) of=generic.b bs=1 count=1 seek=7 conv=notrunc
 	$(DD) if=/dev/zero of=generic.b bs=4 count=1 seek=255
 
 fd.o: fd.S
@@ -83,8 +83,8 @@
 
 fd.b: fd
 	$(ELFTOAOUT) -o fd.b fd
-	echo -n 'SILO'$(IMGVERSION) | $(DD) of=fd.b bs=8 conv=notrunc seek=3 count=1
-	echo -n -e '\340' | $(DD) of=fd.b bs=1 count=1 seek=7 conv=notrunc
+	printf 'SILO'$(IMGVERSION) | $(DD) of=fd.b bs=8 conv=notrunc seek=3 count=1
+	printf '\340' | $(DD) of=fd.b bs=1 count=1 seek=7 conv=notrunc
 	$(DD) if=/dev/zero of=fd.b bs=4 count=1 seek=255
 
 ieee32.o: ieee32.S ieee32.h
diff -Nur silo-1.4.13/first-isofs/isofs.c silo/first-isofs/isofs.c
--- silo-1.4.13/first-isofs/isofs.c	2006-06-21 07:49:46.000000000 +0000
+++ silo/first-isofs/isofs.c	2007-10-08 17:39:27.963921250 +0000
@@ -281,8 +281,9 @@
 
 			if (cd_read_block(cont_extent, 1, sect_buf) < 0)
 				return;
-			parse_rr(&sect_buf[cont_offset], &sect_buf[cont_offset +
-				 cont_size - 3], name, symlink);
+			parse_rr((unsigned char *)(&sect_buf[cont_offset]),
+				 (unsigned char *)(&sect_buf[cont_offset +
+				 cont_size - 3]), name, symlink);
 		}
 	}
 
@@ -330,7 +331,7 @@
 				rr++;
 
 			*symlink = 0;
-			parse_rr(rr, &buffer[i-3], namebuf, symlink);
+			parse_rr(rr, (unsigned char *)(&buffer[i-3]), namebuf, symlink);
 
 			if (idr->name_len[0] == 1 && !idr->name[0]) {
 				namebuf[0] = '.';
@@ -466,7 +467,7 @@
 
 	prom_putchar(sinfo->id);
 
-	return dest;
+	return (char *)dest;
 }
 
 
diff -Nur silo-1.4.13/include/ext2fs/ext2fs.h silo/include/ext2fs/ext2fs.h
--- silo-1.4.13/include/ext2fs/ext2fs.h	2006-06-01 17:24:53.000000000 +0000
+++ silo/include/ext2fs/ext2fs.h	2007-10-08 17:39:27.967921500 +0000
@@ -868,6 +868,8 @@
 extern int ext2fs_test_bb_dirty(ext2_filsys fs);
 extern int ext2fs_group_of_blk(ext2_filsys fs, blk_t blk);
 extern int ext2fs_group_of_ino(ext2_filsys fs, ino_t ino);
+extern blk_t ext2fs_inode_data_blocks(ext2_filsys fs,
+				     struct ext2_inode *inode);
 
 /*
  * The actual inlined functions definitions themselves...
diff -Nur silo-1.4.13/include/silo.h silo/include/silo.h
--- silo-1.4.13/include/silo.h	2006-06-01 17:24:53.000000000 +0000
+++ silo/include/silo.h	2007-10-08 17:39:27.967921500 +0000
@@ -94,7 +94,9 @@
 void mark (void **);
 void release (void *);
 /* file.c */
-int silo_load_file(char *, int, char *, char *, char *, int *, int, void (*)(int, char **, char **));
+int silo_load_file(char *, int, char *, unsigned char *,
+		   unsigned char *, int *, int,
+		   void (*)(int, char **, char **));
 /* misc.c */
 void silo_fatal(const char *);
 char *silo_get_bootargs(int);
diff -Nur silo-1.4.13/include/ufs/ufs_fs.h silo/include/ufs/ufs_fs.h
--- silo-1.4.13/include/ufs/ufs_fs.h	1970-01-01 00:00:00.000000000 +0000
+++ silo/include/ufs/ufs_fs.h	2007-10-08 17:39:27.967921500 +0000
@@ -0,0 +1,1018 @@
+/*
+ *  linux/include/linux/ufs_fs.h
+ *
+ * Copyright (C) 1996
+ * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)
+ * Laboratory for Computer Science Research Computing Facility
+ * Rutgers, The State University of New Jersey
+ *
+ * Clean swab support by Fare <fare@tunes.org>
+ * just hope no one is using NNUUXXI on __?64 structure elements
+ * 64-bit clean thanks to Maciej W. Rozycki <macro@ds2.pg.gda.pl>
+ *
+ * 4.4BSD (FreeBSD) support added on February 1st 1998 by
+ * Niels Kristian Bech Jensen <nkbj@image.dk> partially based
+ * on code by Martin von Loewis <martin@mira.isdn.cs.tu-berlin.de>.
+ *
+ * NeXTstep support added on February 5th 1998 by
+ * Niels Kristian Bech Jensen <nkbj@image.dk>.
+ *
+ * Write support by Daniel Pirkl <daniel.pirkl@email.cz>
+ *
+ * HP/UX hfs filesystem support added by
+ * Martin K. Petersen <mkp@mkp.net>, August 1999
+ *
+ * UFS2 (of FreeBSD 5.x) support added by
+ * Niraj Kumar <niraj17@iitbombay.org>  , Jan 2004
+ *
+ */
+
+#ifndef __LINUX_UFS_FS_H
+#define __LINUX_UFS_FS_H
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/stat.h>
+#include <linux/fs.h>
+
+#ifndef __KERNEL__
+typedef __u64 __fs64;
+typedef __u32 __fs32;
+typedef __u16 __fs16;
+#else
+typedef __u64 __bitwise __fs64;
+typedef __u32 __bitwise __fs32;
+typedef __u16 __bitwise __fs16;
+#endif
+
+#include <ufs/ufs_fs_i.h>
+#include <ufs/ufs_fs_sb.h>
+
+#define UFS_BBLOCK 0
+#define UFS_BBSIZE 8192
+#define UFS_SBLOCK 8192
+#define UFS_SBSIZE 8192
+
+#define UFS_SECTOR_SIZE 512
+#define UFS_SECTOR_BITS 9
+#define UFS_MAGIC  0x00011954
+#define UFS2_MAGIC 0x19540119
+#define UFS_CIGAM  0x54190100 /* byteswapped MAGIC */
+
+/* Copied from FreeBSD */
+/*
+ * Each disk drive contains some number of filesystems.
+ * A filesystem consists of a number of cylinder groups.
+ * Each cylinder group has inodes and data.
+ *
+ * A filesystem is described by its super-block, which in turn
+ * describes the cylinder groups.  The super-block is critical
+ * data and is replicated in each cylinder group to protect against
+ * catastrophic loss.  This is done at `newfs' time and the critical
+ * super-block data does not change, so the copies need not be
+ * referenced further unless disaster strikes.
+ *
+ * For filesystem fs, the offsets of the various blocks of interest
+ * are given in the super block as:
+ *      [fs->fs_sblkno]         Super-block
+ *      [fs->fs_cblkno]         Cylinder group block
+ *      [fs->fs_iblkno]         Inode blocks
+ *      [fs->fs_dblkno]         Data blocks
+ * The beginning of cylinder group cg in fs, is given by
+ * the ``cgbase(fs, cg)'' macro.
+ *
+ * Depending on the architecture and the media, the superblock may
+ * reside in any one of four places. For tiny media where every block
+ * counts, it is placed at the very front of the partition. Historically,
+ * UFS1 placed it 8K from the front to leave room for the disk label and
+ * a small bootstrap. For UFS2 it got moved to 64K from the front to leave
+ * room for the disk label and a bigger bootstrap, and for really piggy
+ * systems we check at 256K from the front if the first three fail. In
+ * all cases the size of the superblock will be SBLOCKSIZE. All values are
+ * given in byte-offset form, so they do not imply a sector size. The
+ * SBLOCKSEARCH specifies the order in which the locations should be searched.
+ */
+#define SBLOCK_FLOPPY        0
+#define SBLOCK_UFS1       8192
+#define SBLOCK_UFS2      65536
+#define SBLOCK_PIGGY    262144
+#define SBLOCKSIZE        8192
+#define SBLOCKSEARCH \
+        { SBLOCK_UFS2, SBLOCK_UFS1, SBLOCK_FLOPPY, SBLOCK_PIGGY, -1 }
+
+
+/* HP specific MAGIC values */
+
+#define UFS_MAGIC_LFN   0x00095014 /* fs supports filenames > 14 chars */
+#define UFS_CIGAM_LFN   0x14500900 /* srahc 41 < semanelif stroppus sf */
+
+#define UFS_MAGIC_SEC   0x00612195 /* B1 security fs */
+#define UFS_CIGAM_SEC   0x95216100
+
+#define UFS_MAGIC_FEA   0x00195612 /* fs_featurebits supported */
+#define UFS_CIGAM_FEA   0x12561900
+
+#define UFS_MAGIC_4GB   0x05231994 /* fs > 4 GB && fs_featurebits */
+#define UFS_CIGAM_4GB   0x94192305
+
+/* Seems somebody at HP goofed here. B1 and lfs are both 0x2 !?! */
+#define UFS_FSF_LFN     0x00000001 /* long file names */
+#define UFS_FSF_B1      0x00000002 /* B1 security */
+#define UFS_FSF_LFS     0x00000002 /* large files */
+#define UFS_FSF_LUID    0x00000004 /* large UIDs */
+
+/* End of HP stuff */
+
+
+#define UFS_BSIZE	8192
+#define UFS_MINBSIZE	4096
+#define UFS_FSIZE	1024
+#define UFS_MAXFRAG	(UFS_BSIZE / UFS_FSIZE)
+
+#define UFS_NDADDR 12
+#define UFS_NINDIR 3
+
+#define UFS_IND_BLOCK	(UFS_NDADDR + 0)
+#define UFS_DIND_BLOCK	(UFS_NDADDR + 1)
+#define UFS_TIND_BLOCK	(UFS_NDADDR + 2)
+
+#define UFS_NDIR_FRAGMENT (UFS_NDADDR << uspi->s_fpbshift)
+#define UFS_IND_FRAGMENT (UFS_IND_BLOCK << uspi->s_fpbshift)
+#define UFS_DIND_FRAGMENT (UFS_DIND_BLOCK << uspi->s_fpbshift)
+#define UFS_TIND_FRAGMENT (UFS_TIND_BLOCK << uspi->s_fpbshift)
+
+#define UFS_ROOTINO 2
+#define UFS_FIRST_INO (UFS_ROOTINO + 1)
+
+#define UFS_USEEFT  ((__u16)65535)
+
+#define UFS_FSOK      0x7c269d38
+#define UFS_FSACTIVE  ((__s8)0x00)
+#define UFS_FSCLEAN   ((__s8)0x01)
+#define UFS_FSSTABLE  ((__s8)0x02)
+#define UFS_FSOSF1    ((__s8)0x03)	/* is this correct for DEC OSF/1? */
+#define UFS_FSBAD     ((__s8)0xff)
+
+/* From here to next blank line, s_flags for ufs_sb_info */
+/* directory entry encoding */
+#define UFS_DE_MASK		0x00000010	/* mask for the following */
+#define UFS_DE_OLD		0x00000000
+#define UFS_DE_44BSD		0x00000010
+/* uid encoding */
+#define UFS_UID_MASK		0x00000060	/* mask for the following */
+#define UFS_UID_OLD		0x00000000
+#define UFS_UID_44BSD		0x00000020
+#define UFS_UID_EFT		0x00000040
+/* superblock state encoding */
+#define UFS_ST_MASK		0x00000700	/* mask for the following */
+#define UFS_ST_OLD		0x00000000
+#define UFS_ST_44BSD		0x00000100
+#define UFS_ST_SUN		0x00000200
+#define UFS_ST_SUNx86		0x00000400
+/*cylinder group encoding */
+#define UFS_CG_MASK		0x00003000	/* mask for the following */
+#define UFS_CG_OLD		0x00000000
+#define UFS_CG_44BSD		0x00002000
+#define UFS_CG_SUN		0x00001000
+/* filesystem type encoding */
+#define UFS_TYPE_MASK		0x00010000	/* mask for the following */
+#define UFS_TYPE_UFS1		0x00000000
+#define UFS_TYPE_UFS2		0x00010000
+
+
+/* fs_inodefmt options */
+#define UFS_42INODEFMT	-1
+#define UFS_44INODEFMT	2
+
+/* mount options */
+#define UFS_MOUNT_ONERROR		0x0000000F
+#define UFS_MOUNT_ONERROR_PANIC		0x00000001
+#define UFS_MOUNT_ONERROR_LOCK		0x00000002
+#define UFS_MOUNT_ONERROR_UMOUNT	0x00000004
+#define UFS_MOUNT_ONERROR_REPAIR	0x00000008
+
+#define UFS_MOUNT_UFSTYPE		0x0000FFF0
+#define UFS_MOUNT_UFSTYPE_OLD		0x00000010
+#define UFS_MOUNT_UFSTYPE_44BSD		0x00000020
+#define UFS_MOUNT_UFSTYPE_SUN		0x00000040
+#define UFS_MOUNT_UFSTYPE_NEXTSTEP	0x00000080
+#define UFS_MOUNT_UFSTYPE_NEXTSTEP_CD	0x00000100
+#define UFS_MOUNT_UFSTYPE_OPENSTEP	0x00000200
+#define UFS_MOUNT_UFSTYPE_SUNx86	0x00000400
+#define UFS_MOUNT_UFSTYPE_HP	        0x00000800
+#define UFS_MOUNT_UFSTYPE_UFS2		0x00001000
+
+#define ufs_clear_opt(o,opt)	o &= ~UFS_MOUNT_##opt
+#define ufs_set_opt(o,opt)	o |= UFS_MOUNT_##opt
+#define ufs_test_opt(o,opt)	((o) & UFS_MOUNT_##opt)
+
+/*
+ * MINFREE gives the minimum acceptable percentage of file system
+ * blocks which may be free. If the freelist drops below this level
+ * only the superuser may continue to allocate blocks. This may
+ * be set to 0 if no reserve of free blocks is deemed necessary,
+ * however throughput drops by fifty percent if the file system
+ * is run at between 95% and 100% full; thus the minimum default
+ * value of fs_minfree is 5%. However, to get good clustering
+ * performance, 10% is a better choice. hence we use 10% as our
+ * default value. With 10% free space, fragmentation is not a
+ * problem, so we choose to optimize for time.
+ */
+#define UFS_MINFREE         5
+#define UFS_DEFAULTOPT      UFS_OPTTIME
+
+/*
+ * Debug code
+ */
+#ifdef CONFIG_UFS_DEBUG
+#	define UFSD(f, a...)	{					\
+		printk ("UFSD (%s, %d): %s:",				\
+			__FILE__, __LINE__, __FUNCTION__);		\
+		printk (f, ## a);					\
+	}
+#else
+#	define UFSD(f, a...)	/**/
+#endif
+            
+/*
+ * Turn file system block numbers into disk block addresses.
+ * This maps file system blocks to device size blocks.
+ */
+#define ufs_fsbtodb(uspi, b)	((b) << (uspi)->s_fsbtodb)
+#define	ufs_dbtofsb(uspi, b)	((b) >> (uspi)->s_fsbtodb)
+
+/*
+ * Cylinder group macros to locate things in cylinder groups.
+ * They calc file system addresses of cylinder group data structures.
+ */
+#define	ufs_cgbase(c)	(uspi->s_fpg * (c))
+#define ufs_cgstart(c)	((uspi)->fs_magic == UFS2_MAGIC ?  ufs_cgbase(c) : \
+	(ufs_cgbase(c)  + uspi->s_cgoffset * ((c) & ~uspi->s_cgmask)))
+#define	ufs_cgsblock(c)	(ufs_cgstart(c) + uspi->s_sblkno)	/* super blk */
+#define	ufs_cgcmin(c)	(ufs_cgstart(c) + uspi->s_cblkno)	/* cg block */
+#define	ufs_cgimin(c)	(ufs_cgstart(c) + uspi->s_iblkno)	/* inode blk */
+#define	ufs_cgdmin(c)	(ufs_cgstart(c) + uspi->s_dblkno)	/* 1st data */
+
+/*
+ * Macros for handling inode numbers:
+ *     inode number to file system block offset.
+ *     inode number to cylinder group number.
+ *     inode number to file system block address.
+ */
+#define	ufs_inotocg(x)		((x) / uspi->s_ipg)
+#define	ufs_inotocgoff(x)	((x) % uspi->s_ipg)
+#define	ufs_inotofsba(x)	(ufs_cgimin(ufs_inotocg(x)) + ufs_inotocgoff(x) / uspi->s_inopf)
+#define	ufs_inotofsbo(x)	((x) % uspi->s_inopf)
+
+/*
+ * Give cylinder group number for a file system block.
+ * Give cylinder group block number for a file system block.
+ */
+#define	ufs_dtog(d)	((d) / uspi->s_fpg)
+#define	ufs_dtogd(d)	((d) % uspi->s_fpg)
+
+/*
+ * Compute the cylinder and rotational position of a cyl block addr.
+ */
+#define ufs_cbtocylno(bno) \
+	((bno) * uspi->s_nspf / uspi->s_spc)
+#define ufs_cbtorpos(bno) \
+	((((bno) * uspi->s_nspf % uspi->s_spc / uspi->s_nsect \
+	* uspi->s_trackskew + (bno) * uspi->s_nspf % uspi->s_spc \
+	% uspi->s_nsect * uspi->s_interleave) % uspi->s_nsect \
+	* uspi->s_nrpos) / uspi->s_npsect)
+
+/*
+ * The following macros optimize certain frequently calculated
+ * quantities by using shifts and masks in place of divisions
+ * modulos and multiplications.
+ */
+#define ufs_blkoff(loc)		((loc) & uspi->s_qbmask)
+#define ufs_fragoff(loc)	((loc) & uspi->s_qfmask)
+#define ufs_lblktosize(blk)	((blk) << uspi->s_bshift)
+#define ufs_lblkno(loc)		((loc) >> uspi->s_bshift)
+#define ufs_numfrags(loc)	((loc) >> uspi->s_fshift)
+#define ufs_blkroundup(size)	(((size) + uspi->s_qbmask) & uspi->s_bmask)
+#define ufs_fragroundup(size)	(((size) + uspi->s_qfmask) & uspi->s_fmask)
+#define ufs_fragstoblks(frags)	((frags) >> uspi->s_fpbshift)
+#define ufs_blkstofrags(blks)	((blks) << uspi->s_fpbshift)
+#define ufs_fragnum(fsb)	((fsb) & uspi->s_fpbmask)
+#define ufs_blknum(fsb)		((fsb) & ~uspi->s_fpbmask)
+
+#define	UFS_MAXNAMLEN 255
+#define UFS_MAXMNTLEN 512
+#define UFS2_MAXMNTLEN 468
+#define UFS2_MAXVOLLEN 32
+/* #define UFS_MAXCSBUFS 31 */
+#define UFS_LINK_MAX 32000
+/*
+#define	UFS2_NOCSPTRS	((128 / sizeof(void *)) - 4)
+*/
+#define	UFS2_NOCSPTRS	28
+
+/*
+ * UFS_DIR_PAD defines the directory entries boundaries
+ * (must be a multiple of 4)
+ */
+#define UFS_DIR_PAD			4
+#define UFS_DIR_ROUND			(UFS_DIR_PAD - 1)
+#define UFS_DIR_REC_LEN(name_len)	(((name_len) + 1 + 8 + UFS_DIR_ROUND) & ~UFS_DIR_ROUND)
+
+struct ufs_timeval {
+	__fs32	tv_sec;
+	__fs32	tv_usec;
+};
+
+struct ufs_dir_entry {
+	__fs32  d_ino;			/* inode number of this entry */
+	__fs16  d_reclen;		/* length of this entry */
+	union {
+		__fs16	d_namlen;		/* actual length of d_name */
+		struct {
+			__u8	d_type;		/* file type */
+			__u8	d_namlen;	/* length of string in d_name */
+		} d_44;
+	} d_u;
+	__u8	d_name[UFS_MAXNAMLEN + 1];	/* file name */
+};
+
+struct ufs_csum {
+	__fs32	cs_ndir;	/* number of directories */
+	__fs32	cs_nbfree;	/* number of free blocks */
+	__fs32	cs_nifree;	/* number of free inodes */
+	__fs32	cs_nffree;	/* number of free frags */
+};
+struct ufs2_csum_total {
+	__fs64	cs_ndir;	/* number of directories */
+	__fs64	cs_nbfree;	/* number of free blocks */
+	__fs64	cs_nifree;	/* number of free inodes */
+	__fs64	cs_nffree;	/* number of free frags */
+	__fs64   cs_numclusters;	/* number of free clusters */
+	__fs64   cs_spare[3];	/* future expansion */
+};
+
+struct ufs_csum_core {
+	__u64	cs_ndir;	/* number of directories */
+	__u64	cs_nbfree;	/* number of free blocks */
+	__u64	cs_nifree;	/* number of free inodes */
+	__u64	cs_nffree;	/* number of free frags */
+	__u64   cs_numclusters;	/* number of free clusters */
+};
+
+/*
+ * File system flags
+ */
+#define UFS_UNCLEAN      0x01    /* file system not clean at mount (unused) */
+#define UFS_DOSOFTDEP    0x02    /* file system using soft dependencies */
+#define UFS_NEEDSFSCK    0x04    /* needs sync fsck (FreeBSD compat, unused) */
+#define UFS_INDEXDIRS    0x08    /* kernel supports indexed directories */
+#define UFS_ACLS         0x10    /* file system has ACLs enabled */
+#define UFS_MULTILABEL   0x20    /* file system is MAC multi-label */
+#define UFS_FLAGS_UPDATED 0x80   /* flags have been moved to new location */
+
+#if 0
+/*
+ * This is the actual superblock, as it is laid out on the disk.
+ * Do NOT use this structure, because of sizeof(ufs_super_block) > 512 and
+ * it may occupy several blocks, use
+ * struct ufs_super_block_(first,second,third) instead.
+ */
+struct ufs_super_block {
+	__fs32	fs_link;	/* UNUSED */
+	__fs32	fs_rlink;	/* UNUSED */
+	__fs32	fs_sblkno;	/* addr of super-block in filesys */
+	__fs32	fs_cblkno;	/* offset of cyl-block in filesys */
+	__fs32	fs_iblkno;	/* offset of inode-blocks in filesys */
+	__fs32	fs_dblkno;	/* offset of first data after cg */
+	__fs32	fs_cgoffset;	/* cylinder group offset in cylinder */
+	__fs32	fs_cgmask;	/* used to calc mod fs_ntrak */
+	__fs32	fs_time;	/* last time written -- time_t */
+	__fs32	fs_size;	/* number of blocks in fs */
+	__fs32	fs_dsize;	/* number of data blocks in fs */
+	__fs32	fs_ncg;		/* number of cylinder groups */
+	__fs32	fs_bsize;	/* size of basic blocks in fs */
+	__fs32	fs_fsize;	/* size of frag blocks in fs */
+	__fs32	fs_frag;	/* number of frags in a block in fs */
+/* these are configuration parameters */
+	__fs32	fs_minfree;	/* minimum percentage of free blocks */
+	__fs32	fs_rotdelay;	/* num of ms for optimal next block */
+	__fs32	fs_rps;		/* disk revolutions per second */
+/* these fields can be computed from the others */
+	__fs32	fs_bmask;	/* ``blkoff'' calc of blk offsets */
+	__fs32	fs_fmask;	/* ``fragoff'' calc of frag offsets */
+	__fs32	fs_bshift;	/* ``lblkno'' calc of logical blkno */
+	__fs32	fs_fshift;	/* ``numfrags'' calc number of frags */
+/* these are configuration parameters */
+	__fs32	fs_maxcontig;	/* max number of contiguous blks */
+	__fs32	fs_maxbpg;	/* max number of blks per cyl group */
+/* these fields can be computed from the others */
+	__fs32	fs_fragshift;	/* block to frag shift */
+	__fs32	fs_fsbtodb;	/* fsbtodb and dbtofsb shift constant */
+	__fs32	fs_sbsize;	/* actual size of super block */
+	__fs32	fs_csmask;	/* csum block offset */
+	__fs32	fs_csshift;	/* csum block number */
+	__fs32	fs_nindir;	/* value of NINDIR */
+	__fs32	fs_inopb;	/* value of INOPB */
+	__fs32	fs_nspf;	/* value of NSPF */
+/* yet another configuration parameter */
+	__fs32	fs_optim;	/* optimization preference, see below */
+/* these fields are derived from the hardware */
+	union {
+		struct {
+			__fs32	fs_npsect;	/* # sectors/track including spares */
+		} fs_sun;
+		struct {
+			__fs32	fs_state;	/* file system state time stamp */
+		} fs_sunx86;
+	} fs_u1;
+	__fs32	fs_interleave;	/* hardware sector interleave */
+	__fs32	fs_trackskew;	/* sector 0 skew, per track */
+/* a unique id for this filesystem (currently unused and unmaintained) */
+/* In 4.3 Tahoe this space is used by fs_headswitch and fs_trkseek */
+/* Neither of those fields is used in the Tahoe code right now but */
+/* there could be problems if they are.                            */
+	__fs32	fs_id[2];	/* file system id */
+/* sizes determined by number of cylinder groups and their sizes */
+	__fs32	fs_csaddr;	/* blk addr of cyl grp summary area */
+	__fs32	fs_cssize;	/* size of cyl grp summary area */
+	__fs32	fs_cgsize;	/* cylinder group size */
+/* these fields are derived from the hardware */
+	__fs32	fs_ntrak;	/* tracks per cylinder */
+	__fs32	fs_nsect;	/* sectors per track */
+	__fs32	fs_spc;		/* sectors per cylinder */
+/* this comes from the disk driver partitioning */
+	__fs32	fs_ncyl;	/* cylinders in file system */
+/* these fields can be computed from the others */
+	__fs32	fs_cpg;		/* cylinders per group */
+	__fs32	fs_ipg;		/* inodes per cylinder group */
+	__fs32	fs_fpg;		/* blocks per group * fs_frag */
+/* this data must be re-computed after crashes */
+	struct ufs_csum fs_cstotal;	/* cylinder summary information */
+/* these fields are cleared at mount time */
+	__s8	fs_fmod;	/* super block modified flag */
+	__s8	fs_clean;	/* file system is clean flag */
+	__s8	fs_ronly;	/* mounted read-only flag */
+	__s8	fs_flags;
+	union {
+		struct {
+			__s8	fs_fsmnt[UFS_MAXMNTLEN];/* name mounted on */
+			__fs32	fs_cgrotor;	/* last cg searched */
+			__fs32	fs_csp[UFS_MAXCSBUFS];/*list of fs_cs info buffers */
+			__fs32	fs_maxcluster;
+			__fs32	fs_cpc;		/* cyl per cycle in postbl */
+			__fs16	fs_opostbl[16][8]; /* old rotation block list head */
+		} fs_u1;
+		struct {
+			__s8  fs_fsmnt[UFS2_MAXMNTLEN];	/* name mounted on */
+			__u8   fs_volname[UFS2_MAXVOLLEN]; /* volume name */
+			__fs64  fs_swuid;		/* system-wide uid */
+			__fs32  fs_pad;	/* due to alignment of fs_swuid */
+			__fs32   fs_cgrotor;     /* last cg searched */
+			__fs32   fs_ocsp[UFS2_NOCSPTRS]; /*list of fs_cs info buffers */
+			__fs32   fs_contigdirs;/*# of contiguously allocated dirs */
+			__fs32   fs_csp;	/* cg summary info buffer for fs_cs */
+			__fs32   fs_maxcluster;
+			__fs32   fs_active;/* used by snapshots to track fs */
+			__fs32   fs_old_cpc;	/* cyl per cycle in postbl */
+			__fs32   fs_maxbsize;/*maximum blocking factor permitted */
+			__fs64   fs_sparecon64[17];/*old rotation block list head */
+			__fs64   fs_sblockloc; /* byte offset of standard superblock */
+			struct  ufs2_csum_total fs_cstotal;/*cylinder summary information*/
+			struct  ufs_timeval    fs_time;		/* last time written */
+			__fs64    fs_size;		/* number of blocks in fs */
+			__fs64    fs_dsize;	/* number of data blocks in fs */
+			__fs64   fs_csaddr;	/* blk addr of cyl grp summary area */
+			__fs64    fs_pendingblocks;/* blocks in process of being freed */
+			__fs32    fs_pendinginodes;/*inodes in process of being freed */
+		} fs_u2;
+	}  fs_u11;
+	union {
+		struct {
+			__fs32	fs_sparecon[53];/* reserved for future constants */
+			__fs32	fs_reclaim;
+			__fs32	fs_sparecon2[1];
+			__fs32	fs_state;	/* file system state time stamp */
+			__fs32	fs_qbmask[2];	/* ~usb_bmask */
+			__fs32	fs_qfmask[2];	/* ~usb_fmask */
+		} fs_sun;
+		struct {
+			__fs32	fs_sparecon[53];/* reserved for future constants */
+			__fs32	fs_reclaim;
+			__fs32	fs_sparecon2[1];
+			__fs32	fs_npsect;	/* # sectors/track including spares */
+			__fs32	fs_qbmask[2];	/* ~usb_bmask */
+			__fs32	fs_qfmask[2];	/* ~usb_fmask */
+		} fs_sunx86;
+		struct {
+			__fs32	fs_sparecon[50];/* reserved for future constants */
+			__fs32	fs_contigsumsize;/* size of cluster summary array */
+			__fs32	fs_maxsymlinklen;/* max length of an internal symlink */
+			__fs32	fs_inodefmt;	/* format of on-disk inodes */
+			__fs32	fs_maxfilesize[2];	/* max representable file size */
+			__fs32	fs_qbmask[2];	/* ~usb_bmask */
+			__fs32	fs_qfmask[2];	/* ~usb_fmask */
+			__fs32	fs_state;	/* file system state time stamp */
+		} fs_44;
+	} fs_u2;
+	__fs32	fs_postblformat;	/* format of positional layout tables */
+	__fs32	fs_nrpos;		/* number of rotational positions */
+	__fs32	fs_postbloff;		/* (__s16) rotation block list head */
+	__fs32	fs_rotbloff;		/* (__u8) blocks for each rotation */
+	__fs32	fs_magic;		/* magic number */
+	__u8	fs_space[1];		/* list of blocks for each rotation */
+};
+#endif/*struct ufs_super_block*/
+
+/*
+ * Preference for optimization.
+ */
+#define UFS_OPTTIME	0	/* minimize allocation time */
+#define UFS_OPTSPACE	1	/* minimize disk fragmentation */
+
+/*
+ * Rotational layout table format types
+ */
+#define UFS_42POSTBLFMT		-1	/* 4.2BSD rotational table format */
+#define UFS_DYNAMICPOSTBLFMT	1	/* dynamic rotational table format */
+
+/*
+ * Convert cylinder group to base address of its global summary info.
+ */
+#define fs_cs(indx) s_csp[(indx)]
+
+/*
+ * Cylinder group block for a file system.
+ *
+ * Writable fields in the cylinder group are protected by the associated
+ * super block lock fs->fs_lock.
+ */
+#define	CG_MAGIC	0x090255
+#define ufs_cg_chkmagic(sb, ucg) \
+	(fs32_to_cpu((sb), (ucg)->cg_magic) == CG_MAGIC)
+
+/*
+ * size of this structure is 172 B
+ */
+struct	ufs_cylinder_group {
+	__fs32	cg_link;		/* linked list of cyl groups */
+	__fs32	cg_magic;		/* magic number */
+	__fs32	cg_time;		/* time last written */
+	__fs32	cg_cgx;			/* we are the cgx'th cylinder group */
+	__fs16	cg_ncyl;		/* number of cyl's this cg */
+	__fs16	cg_niblk;		/* number of inode blocks this cg */
+	__fs32	cg_ndblk;		/* number of data blocks this cg */
+	struct	ufs_csum cg_cs;		/* cylinder summary information */
+	__fs32	cg_rotor;		/* position of last used block */
+	__fs32	cg_frotor;		/* position of last used frag */
+	__fs32	cg_irotor;		/* position of last used inode */
+	__fs32	cg_frsum[UFS_MAXFRAG];	/* counts of available frags */
+	__fs32	cg_btotoff;		/* (__u32) block totals per cylinder */
+	__fs32	cg_boff;		/* (short) free block positions */
+	__fs32	cg_iusedoff;		/* (char) used inode map */
+	__fs32	cg_freeoff;		/* (u_char) free block map */
+	__fs32	cg_nextfreeoff;		/* (u_char) next available space */
+	union {
+		struct {
+			__fs32	cg_clustersumoff;	/* (u_int32) counts of avail clusters */
+			__fs32	cg_clusteroff;		/* (u_int8) free cluster map */
+			__fs32	cg_nclusterblks;	/* number of clusters this cg */
+			__fs32	cg_sparecon[13];	/* reserved for future use */
+		} cg_44;
+		struct {
+			__fs32	cg_clustersumoff;/* (u_int32) counts of avail clusters */
+			__fs32	cg_clusteroff;	/* (u_int8) free cluster map */
+			__fs32	cg_nclusterblks;/* number of clusters this cg */
+			__fs32   cg_niblk; /* number of inode blocks this cg */
+			__fs32   cg_initediblk;	/* last initialized inode */
+			__fs32   cg_sparecon32[3];/* reserved for future use */
+			__fs64   cg_time;	/* time last written */
+			__fs64	cg_sparecon[3];	/* reserved for future use */
+		} cg_u2;
+		__fs32	cg_sparecon[16];	/* reserved for future use */
+	} cg_u;
+	__u8	cg_space[1];		/* space for cylinder group maps */
+/* actually longer */
+};
+
+/*
+ * structure of an on-disk inode
+ */
+struct ufs_inode {
+	__fs16	ui_mode;		/*  0x0 */
+	__fs16	ui_nlink;		/*  0x2 */
+	union {
+		struct {
+			__fs16	ui_suid;	/*  0x4 */
+			__fs16	ui_sgid;	/*  0x6 */
+		} oldids;
+		__fs32	ui_inumber;		/*  0x4 lsf: inode number */
+		__fs32	ui_author;		/*  0x4 GNU HURD: author */
+	} ui_u1;
+	__fs64	ui_size;		/*  0x8 */
+	struct ufs_timeval ui_atime;	/* 0x10 access */
+	struct ufs_timeval ui_mtime;	/* 0x18 modification */
+	struct ufs_timeval ui_ctime;	/* 0x20 creation */
+	union {
+		struct {
+			__fs32	ui_db[UFS_NDADDR];/* 0x28 data blocks */
+			__fs32	ui_ib[UFS_NINDIR];/* 0x58 indirect blocks */
+		} ui_addr;
+		__u8	ui_symlink[4*(UFS_NDADDR+UFS_NINDIR)];/* 0x28 fast symlink */
+	} ui_u2;
+	__fs32	ui_flags;		/* 0x64 immutable, append-only... */
+	__fs32	ui_blocks;		/* 0x68 blocks in use */
+	__fs32	ui_gen;			/* 0x6c like ext2 i_version, for NFS support */
+	union {
+		struct {
+			__fs32	ui_shadow;	/* 0x70 shadow inode with security data */
+			__fs32	ui_uid;		/* 0x74 long EFT version of uid */
+			__fs32	ui_gid;		/* 0x78 long EFT version of gid */
+			__fs32	ui_oeftflag;	/* 0x7c reserved */
+		} ui_sun;
+		struct {
+			__fs32	ui_uid;		/* 0x70 File owner */
+			__fs32	ui_gid;		/* 0x74 File group */
+			__fs32	ui_spare[2];	/* 0x78 reserved */
+		} ui_44;
+		struct {
+			__fs32	ui_uid;		/* 0x70 */
+			__fs32	ui_gid;		/* 0x74 */
+			__fs16	ui_modeh;	/* 0x78 mode high bits */
+			__fs16	ui_spare;	/* 0x7A unused */
+			__fs32	ui_trans;	/* 0x7c filesystem translator */
+		} ui_hurd;
+	} ui_u3;
+};
+
+#define UFS_NXADDR  2            /* External addresses in inode. */
+struct ufs2_inode {
+	__fs16     ui_mode;        /*   0: IFMT, permissions; see below. */
+	__fs16     ui_nlink;       /*   2: File link count. */
+	__fs32     ui_uid;         /*   4: File owner. */
+	__fs32     ui_gid;         /*   8: File group. */
+	__fs32     ui_blksize;     /*  12: Inode blocksize. */
+	__fs64     ui_size;        /*  16: File byte count. */
+	__fs64     ui_blocks;      /*  24: Bytes actually held. */
+	struct ufs_timeval   ui_atime;       /*  32: Last access time. */
+	struct ufs_timeval   ui_mtime;       /*  40: Last modified time. */
+	struct ufs_timeval   ui_ctime;       /*  48: Last inode change time. */
+	struct ufs_timeval   ui_birthtime;   /*  56: Inode creation time. */
+	__fs32     ui_mtimensec;   /*  64: Last modified time. */
+	__fs32     ui_atimensec;   /*  68: Last access time. */
+	__fs32     ui_ctimensec;   /*  72: Last inode change time. */
+	__fs32     ui_birthnsec;   /*  76: Inode creation time. */
+	__fs32     ui_gen;         /*  80: Generation number. */
+	__fs32     ui_kernflags;   /*  84: Kernel flags. */
+	__fs32     ui_flags;       /*  88: Status flags (chflags). */
+	__fs32     ui_extsize;     /*  92: External attributes block. */
+	__fs64     ui_extb[UFS_NXADDR];/*  96: External attributes block. */
+	union {
+		struct {
+			__fs64     ui_db[UFS_NDADDR]; /* 112: Direct disk blocks. */
+			__fs64     ui_ib[UFS_NINDIR];/* 208: Indirect disk blocks.*/
+		} ui_addr;
+	__u8	ui_symlink[2*4*(UFS_NDADDR+UFS_NINDIR)];/* 0x28 fast symlink */
+	} ui_u2;
+	__fs64     ui_spare[3];    /* 232: Reserved; currently unused */
+};
+
+
+/* FreeBSD has these in sys/stat.h */
+/* ui_flags that can be set by a file owner */
+#define UFS_UF_SETTABLE   0x0000ffff
+#define UFS_UF_NODUMP     0x00000001  /* do not dump */
+#define UFS_UF_IMMUTABLE  0x00000002  /* immutable (can't "change") */
+#define UFS_UF_APPEND     0x00000004  /* append-only */
+#define UFS_UF_OPAQUE     0x00000008  /* directory is opaque (unionfs) */
+#define UFS_UF_NOUNLINK   0x00000010  /* can't be removed or renamed */
+/* ui_flags that only root can set */
+#define UFS_SF_SETTABLE   0xffff0000
+#define UFS_SF_ARCHIVED   0x00010000  /* archived */
+#define UFS_SF_IMMUTABLE  0x00020000  /* immutable (can't "change") */
+#define UFS_SF_APPEND     0x00040000  /* append-only */
+#define UFS_SF_NOUNLINK   0x00100000  /* can't be removed or renamed */
+
+/*
+ * This structure is used for reading disk structures larger
+ * than the size of fragment.
+ */
+struct ufs_buffer_head {
+	__u64 fragment;			/* first fragment */
+	__u64 count;				/* number of fragments */
+	struct buffer_head * bh[UFS_MAXFRAG];	/* buffers */
+};
+
+struct ufs_cg_private_info {
+	struct ufs_buffer_head c_ubh;
+	__u32	c_cgx;		/* number of cylidner group */
+	__u16	c_ncyl;		/* number of cyl's this cg */
+	__u16	c_niblk;	/* number of inode blocks this cg */
+	__u32	c_ndblk;	/* number of data blocks this cg */
+	__u32	c_rotor;	/* position of last used block */
+	__u32	c_frotor;	/* position of last used frag */
+	__u32	c_irotor;	/* position of last used inode */
+	__u32	c_btotoff;	/* (__u32) block totals per cylinder */
+	__u32	c_boff;		/* (short) free block positions */
+	__u32	c_iusedoff;	/* (char) used inode map */
+	__u32	c_freeoff;	/* (u_char) free block map */
+	__u32	c_nextfreeoff;	/* (u_char) next available space */
+	__u32	c_clustersumoff;/* (u_int32) counts of avail clusters */
+	__u32	c_clusteroff;	/* (u_int8) free cluster map */
+	__u32	c_nclusterblks;	/* number of clusters this cg */
+};	
+
+struct ufs_sb_private_info {
+	struct ufs_buffer_head s_ubh; /* buffer containing super block */
+	struct ufs_csum_core cs_total;
+	__u32	s_sblkno;	/* offset of super-blocks in filesys */
+	__u32	s_cblkno;	/* offset of cg-block in filesys */
+	__u32	s_iblkno;	/* offset of inode-blocks in filesys */
+	__u32	s_dblkno;	/* offset of first data after cg */
+	__u32	s_cgoffset;	/* cylinder group offset in cylinder */
+	__u32	s_cgmask;	/* used to calc mod fs_ntrak */
+	__u32	s_size;		/* number of blocks (fragments) in fs */
+	__u32	s_dsize;	/* number of data blocks in fs */
+	__u64	s_u2_size;	/* ufs2: number of blocks (fragments) in fs */
+	__u64	s_u2_dsize;	/*ufs2:  number of data blocks in fs */
+	__u32	s_ncg;		/* number of cylinder groups */
+	__u32	s_bsize;	/* size of basic blocks */
+	__u32	s_fsize;	/* size of fragments */
+	__u32	s_fpb;		/* fragments per block */
+	__u32	s_minfree;	/* minimum percentage of free blocks */
+	__u32	s_bmask;	/* `blkoff'' calc of blk offsets */
+	__u32	s_fmask;	/* s_fsize mask */
+	__u32	s_bshift;	/* `lblkno'' calc of logical blkno */
+	__u32   s_fshift;	/* s_fsize shift */
+	__u32	s_fpbshift;	/* fragments per block shift */
+	__u32	s_fsbtodb;	/* fsbtodb and dbtofsb shift constant */
+	__u32	s_sbsize;	/* actual size of super block */
+	__u32   s_csmask;	/* csum block offset */
+	__u32	s_csshift;	/* csum block number */
+	__u32	s_nindir;	/* value of NINDIR */
+	__u32	s_inopb;	/* value of INOPB */
+	__u32	s_nspf;		/* value of NSPF */
+	__u32	s_npsect;	/* # sectors/track including spares */
+	__u32	s_interleave;	/* hardware sector interleave */
+	__u32	s_trackskew;	/* sector 0 skew, per track */
+	__u32	s_csaddr;	/* blk addr of cyl grp summary area */
+	__u32	s_cssize;	/* size of cyl grp summary area */
+	__u32	s_cgsize;	/* cylinder group size */
+	__u32	s_ntrak;	/* tracks per cylinder */
+	__u32	s_nsect;	/* sectors per track */
+	__u32	s_spc;		/* sectors per cylinder */
+	__u32	s_ipg;		/* inodes per cylinder group */
+	__u32	s_fpg;		/* fragments per group */
+	__u32	s_cpc;		/* cyl per cycle in postbl */
+	__s32	s_contigsumsize;/* size of cluster summary array, 44bsd */
+	__s64	s_qbmask;	/* ~usb_bmask */
+	__s64	s_qfmask;	/* ~usb_fmask */
+	__s32	s_postblformat;	/* format of positional layout tables */
+	__s32	s_nrpos;	/* number of rotational positions */
+        __s32	s_postbloff;	/* (__s16) rotation block list head */
+	__s32	s_rotbloff;	/* (__u8) blocks for each rotation */
+
+	__u32	s_fpbmask;	/* fragments per block mask */
+	__u32	s_apb;		/* address per block */
+	__u32	s_2apb;		/* address per block^2 */
+	__u32	s_3apb;		/* address per block^3 */
+	__u32	s_apbmask;	/* address per block mask */
+	__u32	s_apbshift;	/* address per block shift */
+	__u32	s_2apbshift;	/* address per block shift * 2 */
+	__u32	s_3apbshift;	/* address per block shift * 3 */
+	__u32	s_nspfshift;	/* number of sector per fragment shift */
+	__u32	s_nspb;		/* number of sector per block */
+	__u32	s_inopf;	/* inodes per fragment */
+	__u32	s_sbbase;	/* offset of NeXTstep superblock */
+	__u32	s_bpf;		/* bits per fragment */
+	__u32	s_bpfshift;	/* bits per fragment shift*/
+	__u32	s_bpfmask;	/* bits per fragment mask */
+
+	__u32	s_maxsymlinklen;/* upper limit on fast symlinks' size */
+	__s32	fs_magic;       /* filesystem magic */
+};
+
+/*
+ * Sizes of this structures are:
+ *	ufs_super_block_first	512
+ *	ufs_super_block_second	512
+ *	ufs_super_block_third	356
+ */
+struct ufs_super_block_first {
+	__fs32	fs_link;
+	__fs32	fs_rlink;
+	__fs32	fs_sblkno;
+	__fs32	fs_cblkno;
+	__fs32	fs_iblkno;
+	__fs32	fs_dblkno;
+	__fs32	fs_cgoffset;
+	__fs32	fs_cgmask;
+	__fs32	fs_time;
+	__fs32	fs_size;
+	__fs32	fs_dsize;
+	__fs32	fs_ncg;
+	__fs32	fs_bsize;
+	__fs32	fs_fsize;
+	__fs32	fs_frag;
+	__fs32	fs_minfree;
+	__fs32	fs_rotdelay;
+	__fs32	fs_rps;
+	__fs32	fs_bmask;
+	__fs32	fs_fmask;
+	__fs32	fs_bshift;
+	__fs32	fs_fshift;
+	__fs32	fs_maxcontig;
+	__fs32	fs_maxbpg;
+	__fs32	fs_fragshift;
+	__fs32	fs_fsbtodb;
+	__fs32	fs_sbsize;
+	__fs32	fs_csmask;
+	__fs32	fs_csshift;
+	__fs32	fs_nindir;
+	__fs32	fs_inopb;
+	__fs32	fs_nspf;
+	__fs32	fs_optim;
+	union {
+		struct {
+			__fs32	fs_npsect;
+		} fs_sun;
+		struct {
+			__fs32	fs_state;
+		} fs_sunx86;
+	} fs_u1;
+	__fs32	fs_interleave;
+	__fs32	fs_trackskew;
+	__fs32	fs_id[2];
+	__fs32	fs_csaddr;
+	__fs32	fs_cssize;
+	__fs32	fs_cgsize;
+	__fs32	fs_ntrak;
+	__fs32	fs_nsect;
+	__fs32	fs_spc;
+	__fs32	fs_ncyl;
+	__fs32	fs_cpg;
+	__fs32	fs_ipg;
+	__fs32	fs_fpg;
+	struct ufs_csum fs_cstotal;
+	__s8	fs_fmod;
+	__s8	fs_clean;
+	__s8	fs_ronly;
+	__s8	fs_flags;
+	__s8	fs_fsmnt[UFS_MAXMNTLEN - 212];
+
+};
+
+struct ufs_super_block_second {
+	union {
+		struct {
+			__s8	fs_fsmnt[212];
+			__fs32	fs_cgrotor;
+			__fs32	fs_csp[UFS_MAXCSBUFS];
+			__fs32	fs_maxcluster;
+			__fs32	fs_cpc;
+			__fs16	fs_opostbl[82];
+		} fs_u1;
+		struct {
+			__s8  fs_fsmnt[UFS2_MAXMNTLEN - UFS_MAXMNTLEN + 212];
+			__u8   fs_volname[UFS2_MAXVOLLEN];
+			__fs64  fs_swuid;
+			__fs32  fs_pad;
+			__fs32   fs_cgrotor;
+			__fs32   fs_ocsp[UFS2_NOCSPTRS];
+			__fs32   fs_contigdirs;
+			__fs32   fs_csp;
+			__fs32   fs_maxcluster;
+			__fs32   fs_active;
+			__fs32   fs_old_cpc;
+			__fs32   fs_maxbsize;
+			__fs64   fs_sparecon64[17];
+			__fs64   fs_sblockloc;
+			__fs64	cs_ndir;
+			__fs64	cs_nbfree;
+		} fs_u2;
+	} fs_un;
+};
+
+struct ufs_super_block_third {
+	union {
+		struct {
+			__fs16	fs_opostbl[46];
+		} fs_u1;
+		struct {
+			__fs64	cs_nifree;	/* number of free inodes */
+			__fs64	cs_nffree;	/* number of free frags */
+			__fs64   cs_numclusters;	/* number of free clusters */
+			__fs64   cs_spare[3];	/* future expansion */
+			struct  ufs_timeval    fs_time;		/* last time written */
+			__fs64    fs_size;		/* number of blocks in fs */
+			__fs64    fs_dsize;	/* number of data blocks in fs */
+			__fs64   fs_csaddr;	/* blk addr of cyl grp summary area */
+			__fs64    fs_pendingblocks;/* blocks in process of being freed */
+			__fs32    fs_pendinginodes;/*inodes in process of being freed */
+		} __attribute__ ((packed)) fs_u2;
+	} fs_un1;
+	union {
+		struct {
+			__fs32	fs_sparecon[53];/* reserved for future constants */
+			__fs32	fs_reclaim;
+			__fs32	fs_sparecon2[1];
+			__fs32	fs_state;	/* file system state time stamp */
+			__fs32	fs_qbmask[2];	/* ~usb_bmask */
+			__fs32	fs_qfmask[2];	/* ~usb_fmask */
+		} fs_sun;
+		struct {
+			__fs32	fs_sparecon[53];/* reserved for future constants */
+			__fs32	fs_reclaim;
+			__fs32	fs_sparecon2[1];
+			__fs32	fs_npsect;	/* # sectors/track including spares */
+			__fs32	fs_qbmask[2];	/* ~usb_bmask */
+			__fs32	fs_qfmask[2];	/* ~usb_fmask */
+		} fs_sunx86;
+		struct {
+			__fs32	fs_sparecon[50];/* reserved for future constants */
+			__fs32	fs_contigsumsize;/* size of cluster summary array */
+			__fs32	fs_maxsymlinklen;/* max length of an internal symlink */
+			__fs32	fs_inodefmt;	/* format of on-disk inodes */
+			__fs32	fs_maxfilesize[2];	/* max representable file size */
+			__fs32	fs_qbmask[2];	/* ~usb_bmask */
+			__fs32	fs_qfmask[2];	/* ~usb_fmask */
+			__fs32	fs_state;	/* file system state time stamp */
+		} fs_44;
+	} fs_un2;
+	__fs32	fs_postblformat;
+	__fs32	fs_nrpos;
+	__fs32	fs_postbloff;
+	__fs32	fs_rotbloff;
+	__fs32	fs_magic;
+	__u8	fs_space[1];
+};
+
+#ifdef __KERNEL__
+
+/* balloc.c */
+extern void ufs_free_fragments (struct inode *, unsigned, unsigned);
+extern void ufs_free_blocks (struct inode *, unsigned, unsigned);
+extern unsigned ufs_new_fragments(struct inode *, __fs32 *, unsigned, unsigned,
+				  unsigned, int *, struct page *);
+
+/* cylinder.c */
+extern struct ufs_cg_private_info * ufs_load_cylinder (struct super_block *, unsigned);
+extern void ufs_put_cylinder (struct super_block *, unsigned);
+
+/* dir.c */
+extern struct inode_operations ufs_dir_inode_operations;
+extern int ufs_add_link (struct dentry *, struct inode *);
+extern ino_t ufs_inode_by_name(struct inode *, struct dentry *);
+extern int ufs_make_empty(struct inode *, struct inode *);
+extern struct ufs_dir_entry *ufs_find_entry(struct inode *, struct dentry *, struct page **);
+extern int ufs_delete_entry(struct inode *, struct ufs_dir_entry *, struct page *);
+extern int ufs_empty_dir (struct inode *);
+extern struct ufs_dir_entry *ufs_dotdot(struct inode *, struct page **);
+extern void ufs_set_link(struct inode *dir, struct ufs_dir_entry *de,
+			 struct page *page, struct inode *inode);
+
+/* file.c */
+extern struct inode_operations ufs_file_inode_operations;
+extern const struct file_operations ufs_file_operations;
+
+extern const struct address_space_operations ufs_aops;
+
+/* ialloc.c */
+extern void ufs_free_inode (struct inode *inode);
+extern struct inode * ufs_new_inode (struct inode *, int);
+
+/* inode.c */
+extern void ufs_read_inode (struct inode *);
+extern void ufs_put_inode (struct inode *);
+extern int ufs_write_inode (struct inode *, int);
+extern int ufs_sync_inode (struct inode *);
+extern void ufs_delete_inode (struct inode *);
+extern struct buffer_head * ufs_bread (struct inode *, unsigned, int, int *);
+extern int ufs_getfrag_block (struct inode *inode, sector_t fragment, struct buffer_head *bh_result, int create);
+
+/* namei.c */
+extern const struct file_operations ufs_dir_operations;
+        
+/* super.c */
+extern void ufs_warning (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
+extern void ufs_error (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
+extern void ufs_panic (struct super_block *, const char *, const char *, ...) __attribute__ ((format (printf, 3, 4)));
+
+/* symlink.c */
+extern struct inode_operations ufs_fast_symlink_inode_operations;
+
+/* truncate.c */
+extern int ufs_truncate (struct inode *, loff_t);
+
+static inline struct ufs_sb_info *UFS_SB(struct super_block *sb)
+{
+	return sb->s_fs_info;
+}
+
+static inline struct ufs_inode_info *UFS_I(struct inode *inode)
+{
+	return container_of(inode, struct ufs_inode_info, vfs_inode);
+}
+
+#endif	/* __KERNEL__ */
+
+#endif /* __LINUX_UFS_FS_H */
diff -Nur silo-1.4.13/include/ufs/ufs_fs_i.h silo/include/ufs/ufs_fs_i.h
--- silo-1.4.13/include/ufs/ufs_fs_i.h	1970-01-01 00:00:00.000000000 +0000
+++ silo/include/ufs/ufs_fs_i.h	2007-10-08 17:39:27.967921500 +0000
@@ -0,0 +1,34 @@
+/*
+ *  linux/include/linux/ufs_fs_i.h
+ *
+ * Copyright (C) 1996
+ * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)
+ * Laboratory for Computer Science Research Computing Facility
+ * Rutgers, The State University of New Jersey
+ *
+ * NeXTstep support added on February 5th 1998 by
+ * Niels Kristian Bech Jensen <nkbj@image.dk>.
+ */
+
+#ifndef _LINUX_UFS_FS_I_H
+#define _LINUX_UFS_FS_I_H
+
+struct ufs_inode_info {
+	union {
+		__fs32	i_data[15];
+		__u8	i_symlink[4*15];
+		__fs64	u2_i_data[15];
+	} i_u1;
+	__u32	i_flags;
+	__u32	i_gen;
+	__u32	i_shadow;
+	__u32	i_unused1;
+	__u32	i_unused2;
+	__u32	i_oeftflag;
+	__u16	i_osync;
+	__u32	i_lastfrag;
+	__u32   i_dir_start_lookup;
+	struct inode vfs_inode;
+};
+
+#endif /* _LINUX_UFS_FS_I_H */
diff -Nur silo-1.4.13/include/ufs/ufs_fs_sb.h silo/include/ufs/ufs_fs_sb.h
--- silo-1.4.13/include/ufs/ufs_fs_sb.h	1970-01-01 00:00:00.000000000 +0000
+++ silo/include/ufs/ufs_fs_sb.h	2007-10-08 17:39:27.967921500 +0000
@@ -0,0 +1,38 @@
+/* 
+ *  linux/include/linux/ufs_fs_sb.h
+ *
+ * Copyright (C) 1996
+ * Adrian Rodriguez (adrian@franklins-tower.rutgers.edu)
+ * Laboratory for Computer Science Research Computing Facility
+ * Rutgers, The State University of New Jersey
+ *
+ * $Id$
+ *
+ * Write support by Daniel Pirkl <daniel.pirkl@email.cz>
+ */
+
+#ifndef __LINUX_UFS_FS_SB_H
+#define __LINUX_UFS_FS_SB_H
+
+
+#define UFS_MAX_GROUP_LOADED 8
+#define UFS_CGNO_EMPTY ((unsigned)-1)
+
+struct ufs_sb_private_info;
+struct ufs_cg_private_info;
+struct ufs_csum;
+#define UFS_MAXCSBUFS 31
+
+struct ufs_sb_info {
+	struct ufs_sb_private_info * s_uspi;	
+	struct ufs_csum	* s_csp;
+	unsigned s_bytesex;
+	unsigned s_flags;
+	struct buffer_head ** s_ucg;
+	struct ufs_cg_private_info * s_ucpi[UFS_MAX_GROUP_LOADED]; 
+	unsigned s_cgno[UFS_MAX_GROUP_LOADED];
+	unsigned short s_cg_loaded;
+	unsigned s_mount_opt;
+};
+
+#endif
diff -Nur silo-1.4.13/second/decomp.c silo/second/decomp.c
--- silo-1.4.13/second/decomp.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/decomp.c	2007-10-08 17:39:27.971921750 +0000
@@ -111,8 +111,8 @@
 	gzip_release (&save_ptr);
 	return -1;
     }
-    output_data = outptr;
-    output_limit = outptrlim;
+    output_data = (uch *)outptr;
+    output_limit = (uch *)outptrlim;
     get_input_fun = get_input;
     unget_input_fun = unget_input;
     bytes_out = 0;
@@ -140,7 +140,7 @@
 extern char main_text_start, main_text_end, main_data_start, main_data_end, main_rodata_start, main_rodata_end, __bss_start;
 
 /* This has to be in data section, so that it does not get cleared. See crt0.S for details. */
-char *gzminpi = (char *)0xdeadbeef;
+unsigned char *gzminpi = (unsigned char *)0xdeadbeef;
 
 extern int bootmain(void);
 
@@ -163,7 +163,7 @@
     	pt++;
     	while (*pt) pt++;
     	pt++;
-    	gzminpi = (char *)pt;
+    	gzminpi = (unsigned char *)pt;
     }
     gzminp = gzminpi;
     if (decompress ((char *)0x200000, (char *)&_start, get_input, unget_input) == -1) {
@@ -174,7 +174,7 @@
     memcpy (&main_rodata_start, (char *)0x200000 + (&main_text_end - &main_text_start), &main_rodata_end - &main_rodata_start);
     memcpy (&main_data_start, (char *)0x200000 + (&main_text_end - &main_text_start) + (&main_rodata_end - &main_rodata_start), &main_data_end - &main_data_start);
     if (cifh) {
-    	unsigned char *cp = (char *)LARGE_RELOC;
+    	unsigned char *cp = (unsigned char *)LARGE_RELOC;
     	unsigned short *pt = (unsigned short *)((char *)0x200000 + (&main_text_end - &main_text_start) + 
     				(&main_rodata_end - &main_rodata_start) + (&main_data_end - &main_data_start));
     	
@@ -184,7 +184,7 @@
     		*cp += 4;
     	}
     	pt++;
-    	cp = (char *)LARGE_RELOC;
+    	cp = (unsigned char *)LARGE_RELOC;
     	while (*pt) {
     		cp += *pt;
     		pt++;
diff -Nur silo-1.4.13/second/file.c silo/second/file.c
--- silo-1.4.13/second/file.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/file.c	2007-10-08 17:39:27.971921750 +0000
@@ -27,14 +27,14 @@
 ext2_filsys fs = 0;
 
 unsigned int bs;
-unsigned char *filebuffer;
+void *filebuffer;
 ino_t root, cwd;
 
 static int do_gunzip = 0;
 static unsigned int *gzipped_blocks;
 static unsigned int *cur_gzipped_block;
 
-static unsigned char *filelimit;
+static char *filelimit;
 static int first_block;
 static int block_no;
 static int block_cnt;
@@ -69,14 +69,14 @@
 			  const char *symlink)
 {
     struct silo_inode *sino = (struct silo_inode *)filebuffer;
-    unsigned char *p;
+    void *p;
     int name_len = strlen(name);
 
     if (match != NULL)
         if (strlen(match) > name_len || strncmp(match, name, strlen(match)))
             return;
 
-    strncpy(sino->name, name, name_len);
+    strncpy((char *)sino->name, name, name_len);
     sino->name[name_len] = 0;
     sino->mtime = mtime;
     sino->size = size;
@@ -84,10 +84,10 @@
     sino->uid = uid;
     sino->gid = gid;
 
-    p = strchr (sino->name, 0) + 1;
+    p = strchr((char *)sino->name, 0) + 1;
     if (symlink) {
-        strncpy (p, symlink, size);
-        p[size] = 0;
+        strncpy ((char *)p, symlink, size);
+        ((char *)p)[size] = 0;
         p += size + 1;
     }
     if ((long)p & 3) p += 4 - ((long)p & 3);
@@ -192,7 +192,7 @@
                 }
                 last_blockcnt = -1;
             }
-            if (filebuffer + (block_cnt + ((*blocknr) ? (blockcnt - last_blockcnt - 1) : 0)) * bs > filelimit) {
+            if ((char *)filebuffer + (block_cnt + ((*blocknr) ? (blockcnt - last_blockcnt - 1) : 0)) * bs > filelimit) {
                 silo_fatal("Image too large to fit in destination");
                 return BLOCK_ABORT;
             }
@@ -201,7 +201,9 @@
             if (first_block) {
                 first_block = 0;
                 last_blockcnt = 0;
-                if (*filebuffer == 037 && (filebuffer[1] == 0213 || filebuffer[1] == 0236)) {   /* gzip magic */
+                if (*(unsigned char *)filebuffer == 037 &&
+			(((unsigned char *)filebuffer)[1] == 0213 ||
+			((unsigned char *)filebuffer)[1] == 0236)) {   /* gzip magic */
                     unsigned long sa = (unsigned long)&_start;
                     gunzip_buffer = malloc (16 * bs);
                     memcpy (gunzip_buffer, filebuffer, bs);
@@ -321,8 +323,8 @@
     return 0;
 }
 
-int silo_load_file(char *device, int partno, char *filename, char *buffer,
-	       char *limit, int *len, int cmd,
+int silo_load_file(char *device, int partno, char *filename, unsigned char *buffer,
+	       unsigned char *limit, int *len, int cmd,
 	       void (*lenfunc)(int, char **, char **))
 {
     struct silo_inode *sino;
@@ -359,7 +361,7 @@
 	do_rotate = 1;
 
     filebuffer = buffer;
-    filelimit = limit;
+    filelimit = (char *)limit;
 
     if (*filename == '[') {
 	if (cmd & LOADFILE_LS) {
diff -Nur silo-1.4.13/second/file.h silo/second/file.h
--- silo-1.4.13/second/file.h	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/file.h	2007-10-08 17:39:27.971921750 +0000
@@ -24,7 +24,7 @@
 
 extern unsigned int bs;			/* Block Size */
 extern io_manager silo_io_manager;	/* The Filesystem I/O Manager */
-extern unsigned char *filebuffer;
+extern void *filebuffer;
 extern ext2_filsys fs;			/* Generic filesystem */
 extern ino_t root, cwd;			/* root and cwd for current fs */
 extern int solaris;
diff -Nur silo-1.4.13/second/fs/ext2.c silo/second/fs/ext2.c
--- silo-1.4.13/second/fs/ext2.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/fs/ext2.c	2007-10-08 17:39:27.971921750 +0000
@@ -91,7 +91,7 @@
 
     if (LINUX_S_ISLNK (ino.i_mode)) {
 	sl = 1;
-	if (ext2fs_inode_data_blocks(fs, ino)) {
+	if (ext2fs_inode_data_blocks(fs, &ino)) {
 	    if (io_channel_read_blk(fs->io, ino.i_block[0], 1, symlink))
 		ino.i_size = 0;
 	} else {
diff -Nur silo-1.4.13/second/fs/isofs.c silo/second/fs/isofs.c
--- silo-1.4.13/second/fs/isofs.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/fs/isofs.c	2007-10-08 17:39:27.971921750 +0000
@@ -259,7 +259,8 @@
 	    char *sect = alloca (2048);
 	    if (io_channel_read_blk (fs->io, cont_extent, 1, sect))
 		return;
-	    parse_rr (fs, &sect [cont_offset], &sect [cont_offset + cont_size - 3],
+	    parse_rr (fs, (unsigned char *)(&sect[cont_offset]),
+		      (unsigned char *)(&sect[cont_offset + cont_size - 3]),
 		      name, symlink, sino);
 	}
     }
@@ -307,7 +308,7 @@
 
 	    *symlink = 0;
 	    memset(&sino, 0, sizeof(struct silo_inode));
-	    parse_rr (fs, rr, &buffer[i-3], namebuf, symlink, &sino);
+	    parse_rr (fs, rr, (unsigned char *)(&buffer[i-3]), namebuf, symlink, &sino);
 
 	    if (idr->name_len[0] == 1 && !idr->name[0])
 		strcpy(namebuf, ".");
diff -Nur silo-1.4.13/second/fs/ufs.c silo/second/fs/ufs.c
--- silo-1.4.13/second/fs/ufs.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/fs/ufs.c	2007-10-08 17:39:27.971921750 +0000
@@ -33,35 +33,25 @@
 
 struct inode { unsigned int blah; };
 
-#include <linux/ufs_fs.h>
+#include <ufs/ufs_fs.h>
 
 /* Reuse and abuse */
 typedef ext2_filsys ufs_filsys;
 
 ino_t inode = 0;
 
-#ifdef UFS_CIGAM
-/* Apparently new header */
-
 #define ufsi_size(x) ((unsigned int)((x)->ui_size))
 #define ufsi_db(x) ((unsigned int *)((x)->ui_u2.ui_addr.ui_db))
 #define ufsi_ib(x) ((unsigned int *)((x)->ui_u2.ui_addr.ui_ib))
 #define ufsd_namlen(x) ((unsigned char)((x)->d_u.d_44.d_namlen))
 
-#ifdef UFS_MINFREE
-/* Apparently even newer header */
-#define ufs_superblock ufs_super_block
+struct ufs_superblock_full {
+	struct ufs_super_block_first first;
+	struct ufs_super_block_second second;
+	struct ufs_super_block_third third;
+};
+#define ufs_superblock ufs_super_block_first
 #define ufs_direct ufs_dir_entry
-#endif
-
-#else
-
-#define ufsi_size(x) (((x)->ui_size.val[1]))
-#define ufsi_db(x) ((unsigned int *)((x)->ui_db))
-#define ufsi_ib(x) ((unsigned int *)((x)->ui_ib))
-#define ufsd_namlen(x) ((unsigned char)((x)->d_namlen))
-
-#endif
 
 #ifndef S_ISLNK
 #include <sys/stat.h>
@@ -92,25 +82,22 @@
         return p;
 }
 
-static struct ufs_superblock *ufs_read_super(ufs_filsys fs)
+static struct ufs_superblock_full *ufs_read_super(ufs_filsys fs)
 {
-    struct ufs_superblock *usb;
+    struct ufs_superblock_full *usb;
 
-    usb = (struct ufs_superblock *) malloc (2048);
+    usb = (struct ufs_superblock_full *) malloc (2048);
     if (!usb) return 0;
     if (io_channel_read_blk (fs->io, UFS_SBLOCK/1024, -2048, (char *)usb))
         return 0;
-    if (usb->fs_magic != UFS_MAGIC) {
-	/* XXX - replace hard-coded constant with a byte-swap macro */
-	if (usb->fs_magic == 0x54190100) {
-	}
+    if (usb->third.fs_magic != UFS_MAGIC) {
 	return 0;
     }
-    if (usb->fs_bsize != UFS_BSIZE)
+    if (usb->first.fs_bsize != UFS_BSIZE)
         return 0;
-    if (usb->fs_fsize != UFS_FSIZE)
+    if (usb->first.fs_fsize != UFS_FSIZE)
         return 0;
-    io_channel_set_blksize (fs->io, usb->fs_fsize);
+    io_channel_set_blksize (fs->io, usb->first.fs_fsize);
     return usb;
 }
 
diff -Nur silo-1.4.13/second/ls.c silo/second/ls.c
--- silo-1.4.13/second/ls.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/ls.c	2007-10-08 17:39:27.971921750 +0000
@@ -31,12 +31,12 @@
 static int do_ls_cmp (struct silo_inode *a, struct silo_inode *b)
 {
     int ret;
-    ret = strcmp (a->name, b->name);
+    ret = strcmp ((char *)a->name, (char *)b->name);
     if (ret) {
-	if (!strcmp (a->name, ".")) return -1;
-	if (!strcmp (b->name, ".")) return 1;
-	if (!strcmp (a->name, "..")) return -1;
-	if (!strcmp (b->name, "..")) return 1;
+	if (!strcmp ((char *)a->name, ".")) return -1;
+	if (!strcmp ((char *)b->name, ".")) return 1;
+	if (!strcmp ((char *)a->name, "..")) return -1;
+	if (!strcmp ((char *)b->name, "..")) return 1;
     }
     if (ls_opt & LSOPT_T) {
 	if (a->mtime < b->mtime)
@@ -202,7 +202,7 @@
 	    print_number (min, 2, '0');
 	    printf (" %d %s", year, array[i]->name);
 	    if (LINUX_S_ISLNK (array[i]->mode)) {
-		q = strchr (array[i]->name, 0) + 1;
+		q = strchr ((char *)array[i]->name, 0) + 1;
 		if (*q) printf (" -> %s", q);
 	    }
 	    printf ("\n");
@@ -216,7 +216,7 @@
 
 	    for (i = 0; i < n; i++) {
 		printf ("%s", array[i]->name);
-		j = 19 - strlen(array[i]->name);
+		j = 19 - strlen((char *)array[i]->name);
 		if ((i & 3) == 3 || i == n - 1)
 		    printf ("\n");
 		else
diff -Nur silo-1.4.13/second/main.c silo/second/main.c
--- silo-1.4.13/second/main.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/main.c	2007-10-08 17:39:27.971921750 +0000
@@ -55,7 +55,7 @@
 
 /* This has to be first initialized variable in main.c */
 
-extern unsigned char silo_conf[256];
+extern char silo_conf[256];
 extern unsigned char silo_conf_part, silo_conf_parts[32], raid_dsk_number;
 
 int useconf = 0;
@@ -871,7 +871,7 @@
 	   initrd_phys, initrd_start);
 }
 
-static int parse_executable (char *base, int image_len, unsigned int *poff,
+static int parse_executable (unsigned char *base, int image_len, unsigned int *poff,
 			     int *plen, unsigned *pstart, char *image_name)
 {
     int isfile = 0;
@@ -889,7 +889,7 @@
     /* the kernel) so we check if it is an executable file, either */
     /* an a.out or an elf binary */
 
-    hp.b = base;
+    hp.b = (char *)base;
     if (hp.a->magic == 0x01030107) {
     	if (solaris) {
     	    printf ("\nYour Solaris `ufsboot' is not an ELF image. Try again.\n");
@@ -1043,7 +1043,7 @@
     int len = 0, image_len;
     char *kname, *params, *device;
     char *proll = 0;
-    char *image_base = (char *) 0x4000;
+    unsigned char *image_base = (unsigned char *) 0x4000;
     char *kernel_params;
     int part;
     int isfile, fileok = 0;
@@ -1095,7 +1095,7 @@
 	if (!fileok || (unsigned) len >= 65535)
 	    printf ("\nCouldn't load %s\n", silo_conf);
 	else {
-	    if (!cfg_parse (silo_conf, (unsigned char *) 0x4000, len)) {
+	    if (!cfg_parse (silo_conf, (char *) 0x4000, len)) {
 		char *p, *q;
 		int len = 0;
 		int defpart = -1;
@@ -1180,11 +1180,12 @@
 	        printf ("\nProll not found.... try again\n");
 		continue;
 	    }
-            if (!parse_executable ((char *)0x4000, image_len, &off, &len, NULL, proll))
+            if (!parse_executable ((unsigned char *)0x4000, image_len, &off,
+				    &len, NULL, proll))
 		continue;
             memcpy ((char *) 0x4000, ((char *) 0x4000) + off, len);
 
-	    image_base = (char *) 0x40000;
+	    image_base = (unsigned char *) 0x40000;
 	    if (!silo_load_file(device, part, kname, image_base,
 				(unsigned char *) &_start, &image_len,
 				LOADFILE_GZIP, 0)) {
@@ -1197,19 +1198,19 @@
 	    ret_offset = 0x4000;
 
 	} else {
-	    char *image_end = (char *)&_start;
+	    unsigned char *image_end = (unsigned char *)&_start;
 
 	    /* See if we can use some extra memory for the kernel */
 	    if (!load_cmd) {
 		unsigned int size;
-		char *mem;
+		unsigned char *mem;
 
 		size = 0x800000;
-		mem = image_memory_find(size);
+		mem = (unsigned char *)image_memory_find(size);
 
 		if (!mem) {
 		    size = 0x400000;
-		    mem = image_memory_find(size);
+		    mem = (unsigned char *)image_memory_find(size);
 		}
 
 		if (mem) {
@@ -1260,9 +1261,9 @@
 	memcpy (image_base, image_base + off, len);
 
         hdrs = (struct HdrS_struct *)
-		silo_find_linux_HdrS(image_base, image_len);
+		silo_find_linux_HdrS((char *)image_base, image_len);
 
-	if (hdrs && hdrs->ver < 0x300 && image_base != (char *)0x4000) {
+	if (hdrs && hdrs->ver < 0x300 && image_base != (unsigned char *)0x4000) {
 	    /* Kernel doesn't support being loaded to other than
 	     * phys_base, so let's try to copy it down there. */
 	    if ((unsigned int)&_start - 0x4000 < len) {
@@ -1279,12 +1280,12 @@
 
 	    /* Ok, it fits, so copy it down there */
 	    memcpy ((char *)0x4000, image_base, len);
-	    image_base = (char *)0x4000;
+	    image_base = (unsigned char *)0x4000;
 
 	    /* Readjust some things */
 	    ret_offset = 0x4000;
 	    hdrs = (struct HdrS_struct *)
-		silo_find_linux_HdrS(image_base, image_len);
+		silo_find_linux_HdrS((char *)image_base, image_len);
 
 	    printf("done.\n");
 	}
@@ -1386,8 +1387,8 @@
 			if (!initrd_kname) break;
 			if (!initrd_device) initrd_device = initrd_defdevice;
 			if (!silo_load_file(initrd_device, initrd_partno,
-					    initrd_kname, initrd_cur,
-					    initrd_limit, &len, 0, 0))
+					    initrd_kname, (unsigned char *)initrd_cur,
+					    (unsigned char *)initrd_limit, &len, 0, 0))
 			  break;
 			initrd_cur += len;
 			if (!c) {
@@ -1432,7 +1433,7 @@
 		    if (initrd_kname) {
 		        if (!initrd_device) initrd_device = initrd_defdevice;
 	        	if (silo_load_file(initrd_device, initrd_partno,
-					   initrd_kname, (char *) 0x300000,
+					   initrd_kname, (unsigned char *) 0x300000,
 					   (unsigned char *) LARGE_RELOC,
 					   0, 0, initrd_lenfunc)) {
 	        	    extern unsigned long long sun4u_initrd_phys;
diff -Nur silo-1.4.13/second/misc.c silo/second/misc.c
--- silo-1.4.13/second/misc.c	2006-06-04 18:28:27.000000000 +0000
+++ silo/second/misc.c	2007-10-08 17:39:27.971921750 +0000
@@ -309,12 +309,12 @@
 
     q = base+8;
     if (*q == 'H' && q[1] == 'd' && q[2] == 'r' && q[3] == 'S')
-    	return q;
+    	return (unsigned char *)q;
     if (p >= base + len || p <= base)
 	return 0;
     for (q = p + 512; p < q; p += 4) {
 	if (*p == 'H' && p[1] == 'd' && p[2] == 'r' && p[3] == 'S')
-	    return p;
+	    return (unsigned char *)p;
     }
     return 0;
 }
diff -Nur silo-1.4.13/second/timer.c silo/second/timer.c
--- silo-1.4.13/second/timer.c	2006-06-01 17:35:26.000000000 +0000
+++ silo/second/timer.c	2007-10-08 17:39:27.971921750 +0000
@@ -216,7 +216,7 @@
         if (addr_to_free == (unsigned char *)0xffffffff)
             sun4c_unmapio (TICKER_VIRTUAL);
         else
-	    (*romvec->pv_v2devops.v2_dumb_munmap)(addr_to_free, len_to_free);
+	    (*romvec->pv_v2devops.v2_dumb_munmap)((char *)addr_to_free, len_to_free);
 	addr_to_free = 0;
     }
 }
diff -Nur silo-1.4.13/second/util.c silo/second/util.c
--- silo-1.4.13/second/util.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/second/util.c	2007-10-08 17:39:27.975922000 +0000
@@ -20,6 +20,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <ctype.h>
+#include <string.h>
 
 FILE *f, *e;
 unsigned char buffer[2048];
diff -Nur silo-1.4.13/silo/silo.c silo/silo/silo.c
--- silo-1.4.13/silo/silo.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/silo/silo.c	2007-10-08 17:39:27.975922000 +0000
@@ -138,8 +138,8 @@
 enum typeenum { TYPE_UNKNOWN, TYPE_SCSI, TYPE_IDE };
 
 struct hwdevice {
-    unsigned char *wholedev;
-    unsigned char *dev;
+    char *wholedev;
+    char *dev;
     enum typeenum type;
     int id;
     int part;
@@ -242,7 +242,7 @@
     int i;
 
     hwdev->partat0 = 0;
-    if ((fd = devopen (hwdev->dev, O_RDONLY)) == -1)
+    if ((fd = devopen ((char *)hwdev->dev, O_RDONLY)) == -1)
 	silo_fatal("Cannot open superblock on %s", hwdev->dev);
     hwdev->bs = check_fs (fd);
     if (hwdev->bs == (unsigned short)-1)
@@ -481,7 +481,8 @@
     __u32 tmp;
     unsigned char part;
 
-    if ((fd = devopen (masterboot ? hwdev->wholedev : hwdev->dev, O_RDWR)) == -1)
+    if ((fd = devopen (masterboot ? hwdev->wholedev : hwdev->dev,
+		       O_RDWR)) == -1)
 	silo_fatal("Cannot open %s", hwdev->dev);
     if (flash_image) off = IEEE32_OFFSET;
     else if (floppy_image) off = 1020 + 512 - 4;
@@ -552,7 +553,7 @@
 	unsigned char partno;
 	unsigned char partat0;
 	unsigned char raid_dsk_number;
-	unsigned char silo_conf[256];
+	char silo_conf[256];
 	unsigned char silover[8];
 	unsigned int len;
 	unsigned char partnos[32];
@@ -1021,10 +1022,7 @@
 				silo_fatal("Only RAID1 supported");
 			hwdev = NULL;
 			last = NULL;
-			for (i = 0; i < md_array_info.nr_disks; i++) {
-				if (i == md_array_info.nr_disks - 1 && md_disk_info.majorno == 0 &&
-				    md_disk_info.minorno == 0)
-					break; // That's all folks
+			for (i = 0; i < md_array_info.raid_disks; i++) {
 				md_disk_info.number = i;
 				if (ioctl (md_fd, GET_DISK_INFO, &md_disk_info) < 0)
 					silo_fatal("Could not get RAID disk "
diff -Nur silo-1.4.13/silo.spec silo/silo.spec
--- silo-1.4.13/silo.spec	2006-06-21 07:51:08.000000000 +0000
+++ silo/silo.spec	2007-10-08 17:39:27.975922000 +0000
@@ -1,20 +1,25 @@
-Summary: The SILO boot loader for SPARCs.
+Summary: A boot loader for SPARCs
 Name: silo
 Version: 1.4.13
-Release: 1
-Copyright: GPL
+Release: 4%{?dist}
+License: GPL
 ExclusiveArch: sparc
 Group: System Environment/Base
+URL: http://www.sparc-boot.org
 Source: http://www.sparc-boot.org/pub/silo/silo-%{version}.tar.gz
 
-BuildRoot: /var/tmp/%{name}-root
+BuildRoot: %{_tmppath}/%{name}-%{version}-root
+BuildPrereq: elftoaout, sed
 
 %description
 The silo package installs the SILO (Sparc Improved LOader) boot
-loader, which you'll need to boot Red Hat Linux on a SPARC.  SILO
+loader, which you'll need to boot Linux on a SPARC.  SILO
 installs onto your system's boot block and can be configured to boot
 Linux, Solaris and SunOS.
 
+The package also includes TILO (Trivial Image LOader), a tool for creating
+TFTP images.
+
 %prep 
 %setup -q -n silo-%{version}
 
@@ -24,13 +29,14 @@
 %install
 rm -rf $RPM_BUILD_ROOT
 make install DESTDIR=$RPM_BUILD_ROOT
+rm -f $RPM_BUILD_ROOT/etc/silo.conf
 
 %clean
 rm -rf $RPM_BUILD_ROOT
 
 %files
-%defattr(-,root,root)
-%doc docs COPYING ChangeLog
+%defattr(-,root,root,-)
+%doc docs COPYING
 /sbin/silo
 /usr/bin/tilo
 /usr/bin/maketilo
@@ -41,6 +47,7 @@
 /boot/ieee32.b
 /boot/silotftp.b
 /boot/second.b
+/boot/generic.b
 /usr/sbin/silocheck
 /usr/share/man/man1/tilo.1*
 /usr/share/man/man1/maketilo.1*
@@ -48,6 +55,20 @@
 /usr/share/man/man8/silo.8*
  
 %changelog
+* Tue Jun  5 2007 Horst H. von Brand <vonbrand@inf.utfsm.cl> 1.4.13-4
+- Copyright tag should be License, add URL tag
+- Add %%{?dist} to release
+- Add /boot/generic.b file
+- Delete /etc/silo.conf
+
+* Fri Jan 05 2007 Horst H. von Brand <vonbrand@inf.utfsm.cl> 1.4.13-3
+- Bring spec into line with Fedora's "Developer's Guide"
+- Add BuildPrereq (if nothing else, it is useful documentation)
+- ChangeLog is no more
+
+* Thu Jan 04 2007 Horst H. von Brand <vonbrand@inf.utfsm.cl> 1.4.13-2
+- Fix RPM description
+
 * Mon May 28 2001 Pieter Krul <pkrul@auxio.org>
 - Updated manpath and added tilo
 
diff -Nur silo-1.4.13/tilo/tilo.c silo/tilo/tilo.c
--- silo-1.4.13/tilo/tilo.c	2006-06-01 17:24:53.000000000 +0000
+++ silo/tilo/tilo.c	2007-10-08 17:39:27.975922000 +0000
@@ -118,8 +118,8 @@
 	gzip_release (&save_ptr);
 	return -1;
     }
-    output_data = outptr;
-    output_limit = outptrlim;
+    output_data = (unsigned char *)outptr;
+    output_limit = (unsigned char *)outptrlim;
     get_input_fun = get_input;
     unget_input_fun = unget_input;
     bytes_out = 0;
@@ -209,7 +209,7 @@
     memmove (moved_ramdisk, orig_code + image_table[ROOT_IMAGE].packed_start, image_table[ROOT_IMAGE].packed_len);
     memmove (moved_kernel, orig_code + image_table[kernel_number].packed_start, image_table[kernel_number].packed_len);
 
-    gzminp = (char*) moved_kernel;		/* decompress kernel */
+    gzminp = (unsigned char *)moved_kernel;		/* decompress kernel */
     kernel_base = (char*) 0x4000;
 
     if (decompress (kernel_base, kernel_base + ((image_table[kernel_number].unpacked_len
